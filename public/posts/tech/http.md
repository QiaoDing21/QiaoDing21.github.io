# _http 响应报文由 3 部分组成：响应行、响应头、响应体_

## 请求行

报文协议 状态码及描述

状态码：
1xx 消息，一般是告诉客户端，请求已经收到了，正在处理，别急...
2xx 处理成功，一般表示：请求收悉、我明白你要的、请求已受理、已经处理完成等信息.
3xx 重定向到其它地方。它让客户端再发起一个请求以完成整个处理。
4xx 处理发生错误，责任在客户端，如客户端的请求一个不存在的资源，客户端未被授权，禁止访问等。
5xx 处理发生错误，责任在服务端，如服务端抛出异常，路由出错，HTTP 版本不支持等。

200 OK 成功  
304 Not Modified 请求的这个资源至你上次取得后，并没有更改，可以直接用本地的缓存
404 Not Found 页面不存在
500 Internal Server Error 服务器问题

## 响应头

1、Cache-Control：响应输出到客户端后，服务端通过该报文头属告诉客户端如何控制响应内容的缓存。

2、ETag：一个代表响应*服务端资源（如页面）版本*的报文头属性，如果某个服务端资源发生变化了，这个 ETag 就会相应发生变化。它是 Cache-Control 的有益补充，可以让客户端“更智能”地处理什么时候要从服务端取资源，什么时候可以直接从缓存中返回响应。

3、Set-Cookie：服务端可以设置客户端的 Cookie，其原理就是通过这个响应报文头属性实现的

# 输入 URL 到页面加载完发生了什么

URL 统一资源定位符，俗称网页地址
URL 中包括：
1、传送协议 protocol：最常用的是 HTTP 协议
2、主机 host：通常为域名或者 IP 地址
3、端口号 port：以数字形式表示
4、路径 path：以“/”字元区别路径中的每一个目录名称
5、查询 query：以“?”字元为起点，每个参数以“&”隔开，再以“=”分开参数名称与其对应的值
6、片段 fragment：也就是在浏览器环境下 location 的 hash 值，用于指定网络资源中的片断，一般用于定位到某个位置

浏览器发生了什么：
1、浏览器查询缓存
2、浏览器询问操作系统服务器的 IP 地址
3、操作系统做 DNS 查询，返回 IP 地址给浏览器
4、浏览器与服务器建立 TCP 连接
5、浏览器通过 TCP 连接发送 HTTP 请求
6、浏览器接收 HTTP 响应
7、浏览器检查响应，并解码，并根据类型处理

如果您在 cookie 中设置了 HttpOnly 属性，那么通过 js 脚本将无法读取到 cookie 信息

页面加载完成有两种事件
一是 ready，表示文档结构已经加载完成（不包含图片等非文字媒体文件）
二是 onload，指示页面包含图片等文件在内的所有元素都加载完成

HTTP 数据 + TCP 首部 + IP 首部 + 以太网首部
应用层 传输层 网络层 链路层

## IP 协议

IP 协议的作用就是把各种数据包传送给对方。传输时需要满足条件是：IP 地址和 MAC 地址
IP 地址指明了结点被分配到的地址，MAC 地址是指网卡所属的固定地址。IP 地址可以和 MAC 地址进行配对。IP 可变，MAC 不可变

IP 间通信依赖 MAC 地址。在网络上，通信的双方在同一局域网内的情况很少，通常需要中转设备，中转时，会利用下一站中转设备的 MAC 地址来搜索下一中转目标。
这时，会采用 ARP 协议来解析地址，根据通信方的 IP 地址就可以反查出对应的 MAC 地址。
（ARP 协议：IP 地址解析成对应的 MAC 地址）

## TCP 协议

TCP 提供可靠字节流服务
字节流服务：为了方便传输，将大块数据分割成报文段为单位的数据包进行管理
可靠服务：能够把数据准确可靠地传给对方，能够确认数据最终是否送达到对方

为了准确送达，TCP 采用了三次握手策略。用 TCP 协议把数据包送出去，TCP 不会置之不理，会向对方确认是否成功送达。握手时采用了 TCP 的标志————SYN 和 ACK

发送端首先发送一个带 SYN 标志的数据包给对方
接收端收到后，回传一个带有 SYN/ACK 标志的数据包以示传达确认信息
发送端再回传一个带 ACK 标志的数据包，代表握手结束

如果握手过程中某个阶段莫名中断，TCP 协议会再次以相同的顺序发送相同的数据包

## DNS 服务

DNS 服务和 HTTP 协议都在应用层。它提供域名到 IP 地址之间的解析服务
DNS 作用：提供通过域名查找 IP 地址，或者逆向从 IP 地址反向查域名的服务

## HTTP 和各种协议的关系

1、客户端向 DNS 发个域名，DNS 服务返回对应的 IP
2、HTTP 向目标服务器发送请求
3、TCP 的协议将 HTTP 请求报文分割成报文段，按序号分为多个报文段，把每个报文段可靠地传给对方
4、IP 协议搜索对方的地址，一边中转一边传送
5、TCP 协议收到了报文段，再按照序号以原来的顺序重组请求报文
6、HTTP 协议拿到内容

## 持久连接

1、多个 HTTP 请求，需要建立多次 TCP 连接，开销太大
2、出现了 HTTP keep-alive 的方法
3、持久连接的特点：只要任意一端没有明确提出断开连接，则保持 TCP 连接状态
4、在 HTTP1.1 中，所有连接默认都是持久连接
5、持久连接使多数请求可以管线化。不用等服务器响应就可以继续发请求

## 内容协商机制

1、服务器驱动协商
由服务器端进行内容协商。以请求的首部字段为参考，在服务端自动处理。但对用户来说，以浏览器发送的信息作为判定的依据。并不一定能筛选出最优内容。

2、客户端驱动协商
由客户端进行内容协商的方式。用户从浏览器显示的可选项列表中手动选择。还可以利用 JS 脚本在 Web 页面上自动进行上述选择。比如按 OS 的类型或浏览器类型，自行切换成 PC 版页面或手机版页面。
3、透明协商
是服务器驱动和客户端驱动的结合体，是由服务器端和客户端各自进行内容协商的一种办法
http1.0 中的缓存控制：

Pragma：严格来说，它不属于专门的缓存控制头部，但是它设置 no-cache 时可以让本地强缓存失效（属于编译控制，来实现特定的指令，主要是因为兼容 http1.0，所以以前又被大量应用）
Expires：服务端配置的，属于强缓存，用来控制在规定的时间之前，浏览器不会发出请求，而是直接使用本地缓存，注意，Expires 一般对应服务器端时间，如 Expires：Fri,
If-Modified-Since/Last-Modified：这两个是成对出现的，属于协商缓存的内容，其中浏览器的头部是 If-Modified-Since，而服务端的是 Last-Modified，它的作用是，在发起请求时，如果 If-Modified-Since 和 Last-Modified 匹配，那么代表服务器资源并未改变，因此服务端不会返回资源实体，而是只返回头部，通知浏览器可以使用本地缓存。Last-Modified，顾名思义，指的是文件最后的修改时间，而且只能精确到 1s 以内
http1.1 中的缓存控制：

Cache-Control：缓存控制头部，有 no-cache、max-age 等多种取值
Max-Age：服务端配置的，用来控制强缓存，在规定的时间之内，浏览器无需发出请求，直接使用本地缓存，注意，Max-Age 是 Cache-Control 头部的值，不是独立的头部，譬如 Cache-Control: max-age=3600，而且它值得是绝对时间，由浏览器自己计算
If-None-Match/E-tag：这两个是成对出现的，属于协商缓存的内容，其中浏览器的头部是 If-None-Match，而服务端的是 E-tag，同样，发出请求后，如果 If-None-Match 和 E-tag 匹配，则代表内容未变，通知浏览器使用本地缓存，和 Last-Modified 不同，E-tag 更精确，它是类似于指纹一样的东西，基于 FileEtag INode Mtime Size 生成，也就是说，只要文件变，指纹就会变，而且没有 1s 精确度的限制。
